---
title: "HA Cluster"
date: 2016-07-24
layout: post
categories: 
- Linux
tags: 
- Linux 
- 运维 
- 网络
published: true
comments: 
---
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline7">1. Cluster</a>
<ul>
<li><a href="#orgheadline1">系统扩展方式</a></li>
<li><a href="#orgheadline2">集群类型</a></li>
<li><a href="#orgheadline3">衡量系统的指标</a></li>
<li><a href="#orgheadline4">高效运维</a></li>
<li><a href="#orgheadline5">session保持</a></li>
<li><a href="#orgheadline6">术语</a></li>
</ul>
</li>
<li><a href="#orgheadline30">2. LB集群</a>
<ul>
<li><a href="#orgheadline8">lvs</a>
<ul>
<li><a href="#orgheadline9">lvs组件</a></li>
<li><a href="#orgheadline10">lvs类型</a></li>
<li><a href="#orgheadline11">lvs scheduler</a></li>
<li><a href="#orgheadline12">lvs架构</a></li>
<li><a href="#orgheadline17">ipvsadm的用法</a></li>
<li><a href="#orgheadline18">配置lvs-dr</a></li>
<li><a href="#orgheadline19">通过FWM定义集群</a></li>
<li><a href="#orgheadline20">lvs persistence</a></li>
<li><a href="#orgheadline21">实现调用RS的高可用</a></li>
</ul>
</li>
<li><a href="#orgheadline29">HAProxy</a>
<ul>
<li><a href="#orgheadline22">代理服务器相关</a></li>
<li><a href="#orgheadline23">负载均衡器算法</a></li>
<li><a href="#orgheadline24">配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<p>
TODO
</p>




<hr  />
<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">1</span> Cluster</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1">系统扩展方式</h3>
<div class="outline-text-3" id="text-orgheadline1">
<ul class="org-ul">
<li>scale up: 向上扩展，使用性能更好的主机</li>
<li>scale out: 向外扩展，使用更多的主机</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">集群类型</h3>
<div class="outline-text-3" id="text-orgheadline2">
<ul class="org-ul">
<li>LB(Load Balancing)：负载均衡集群，任务分配
<ul class="org-ul">
<li>基于软硬件划分
<ul class="org-ul">
<li>硬件: F5、NetScaler、A10、Array、Redware</li>
<li>软件: LVS、HAProxy、Nginx、ats、perlbal</li>
</ul></li>
<li>基于工作的协议层次划分
<ul class="org-ul">
<li>传输层：lvs, haproxy(mode tcp)</li>
<li>应用层：haproxy, nginx, ats, perlbal</li>
</ul></li>
</ul></li>
<li>HA(High Availability)：高可用集群，系统快速修复
<ul class="org-ul">
<li>Availability=可用时间/总时间</li>
<li>vrrp: keepalived</li>
<li>AIS: heartbeat, OpenAIS, corosync/pacemaker, cman/rgmanager(conga)</li>
</ul></li>
<li>HP(High Performancing)：高性能集群，并行处理、分布式
<ul class="org-ul">
<li>分布式应用</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">衡量系统的指标</h3>
<div class="outline-text-3" id="text-orgheadline3">
<ul class="org-ul">
<li>可扩展性
<ul class="org-ul">
<li>构建高可扩展性系统的重要原则：在系统内部尽量避免串行化和交互</li>
</ul></li>
<li>可用性</li>
<li>容量: 请求处理的最大量</li>
<li>吞吐量: 单位时间的请求处理量</li>
<li>性能: 请求处理时间</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">高效运维</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
可用 &#x2013;&gt; 标准化 &#x2013;&gt; 自动化
</p>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">session保持</h3>
<div class="outline-text-3" id="text-orgheadline5">
<ul class="org-ul">
<li>session绑定：基于cookie进行绑定</li>
<li>session集群：解决所有主机的session的同步问题</li>
<li>session服务器：解决session的可用性，可使用memcached、redis</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">术语</h3>
<div class="outline-text-3" id="text-orgheadline6">
<ul class="org-ul">
<li>调度器(负载均衡器)：director, dispatcher, balancer</li>
<li>RS: Real Server</li>
<li>Client IP: CIP</li>
<li>Director Virutal IP: VIP</li>
<li>Director IP: DIP</li>
<li>Real Server IP: RIP</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgheadline30" class="outline-2">
<h2 id="orgheadline30"><span class="section-number-2">2</span> LB集群</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">lvs</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
lvs: Linux Virtual Server，根据请求报文的目标IP和PORT将其转发至后端主机集群中的某一台主机(根据挑选算法)，支持TCP, UDP, AH, ESP, AH_ESP, SCTP等诸多协议
</p>
</div>
<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9">lvs组件</h4>
<div class="outline-text-4" id="text-orgheadline9">
<ul class="org-ul">
<li>ipvsadm: 用户空间的命令行工具，用于管理集群服务</li>
<li>ipvs: 工作内核中netfilter INPUT钩子上，报文传输线路为PREROUTING &#x2013;&gt; INPUT &#x2013;&gt; POSTROUTING</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">lvs类型</h4>
<div class="outline-text-4" id="text-orgheadline10">
<dl class="org-dl">
<dt>lvs-nat</dt><dd>多目标的DNAT，它通过修改请求报文的目标IP地址(同时可能会修改目标端口)至某RS的RIP地址实现转发
<ol class="org-ol">
<li>RIP和DIP应该使用私网地址，且RS的网关要指向DIP</li>
<li>请求和响应报文都要经由director转发，在极高负载的场景中，director可能会成为系统瓶颈</li>
<li>支持端口映射</li>
<li>RS可以使用任意OS</li>
</ol></dd>
<dt>lvs-dr</dt><dd>direct routing(默认)，它通过修改请求报文的目标MAC地址进行转发，仅请求报文经由director，响应报文是由RS直接响应给Client
<ol class="org-ol">
<li>Driector使用VIP、DIP；RS使用RIP、VIP</li>
<li>保证前端路由器将目标IP为VIP的请求报文发送给director，可以通过路由静态绑定、使用arptables使RS拒绝响应、直接修改RS主机内核的参数</li>
<li>RS的RIP可以使用私有地址；但也可以使用公网地址</li>
<li>RS跟Director必须在同一物理网络中</li>
<li>请求报文经由Director调度，但响应报文一定不能经由Director</li>
<li>不支持端口映射</li>
<li>RS可以大多数OS</li>
<li>RS通过地址为VIP的lo设备进行操作</li>
<li>RS的网关不能指向DIP，应指向外网路由</li>
</ol></dd>
<dt>lvs-tun</dt><dd>不修改请求报文的IP首部，而是通过在原有的IP首部(CIP,VIP)之外，再封装一个IP首部(DIP,RIP)
<ol class="org-ol">
<li>RIP、DIP、VIP都是公网地址</li>
<li>RS通过地址为VIP的lo设备接受和发送报文</li>
<li>请求报文必须经由director调度，但响应报文必须不能经由director</li>
<li>不支持端口映射</li>
<li>RS的OS必须支持隧道功能</li>
<li>必要时需要限制请求报文的MTU大小</li>
</ol></dd>
<dt>lvs-fullnat</dt><dd>director通过同时修改请求报文的目标地址和源地址进行转发，需要使用淘宝开源项目进行支持
<ol class="org-ol">
<li>VIP是公网地址；RIP和DIP是私网地址，二者无须在同一网络中</li>
<li>RS接收到的请求报文的源地址为DIP</li>
<li>请求报文和响应报文都必须经由Director</li>
<li>支持端口映射机制</li>
<li>RS可以使用任意OS</li>
</ol></dd>
</dl>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11">lvs scheduler</h4>
<div class="outline-text-4" id="text-orgheadline11">
<p>
scheduler是Director通过算法来选择要调度的RS
</p>
<ul class="org-ul">
<li>静态方法: 仅根据算法本身进行调度
<ul class="org-ul">
<li>RR(round robin): 轮调</li>
<li>WRR(weighted rr): 按照权重分配</li>
<li>SH(source hash): 将来自于同一个IP的请求始终调度至同一RS，实现session保持的机制，但只适用于同个端口</li>
<li>DH(destination hash): 将对同一个目标的请求始终发往同一个RS，对于新目标使用轮调分配，用于正向代理情形下的缓存服务器调度</li>
</ul></li>
<li>动态方法: 根据算法计算各RS的当前负载状态(Overhead)进行调度，其中Active是活动连接数，Inactive是非活动连接数
<ul class="org-ul">
<li>LC(Least Connection): Overhead=Active*256+Inactive</li>
<li>WLC(Weighted LC): Overhead=(Active*256+Inactive)/weight</li>
<li>SED(Shortest Expection Delay): Overhead=(Active+1)*256/weight，解决WLC下0连接数时的分配</li>
<li>NQ(Never Queue): SED算法的改进，优先分配给0连接数的RS</li>
<li>LBLC(Locality-Based LC): 动态的DH算法，对于新目标使用LC分配，用于正向代理情形下的缓存服务器调度</li>
<li>LBLCR(Locality-Based Least-Connection with Replication): 带复制功能的LBLC算法</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12">lvs架构</h4>
<div class="outline-text-4" id="text-orgheadline12">
<ol class="org-ol">
<li>一个ipvs主机可以同时定义多个cluster service</li>
<li>一个cluster service上至少应该一个real server</li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17">ipvsadm的用法</h4>
<div class="outline-text-4" id="text-orgheadline17">
</div><ul class="org-ul"><li><a id="orgheadline13"></a>管理集群服务<br  /><div class="outline-text-5" id="text-orgheadline13">
<div class="org-src-container">

<pre class="src src-conf">ipvsadm -A|-E service [-s scheduler] [-p SECOND] <span style="color: #75715E;"># </span><span style="color: #75715E;">APPEND</span>
ipvsadm -D service  <span style="color: #75715E;"># </span><span style="color: #75715E;">DELETE</span>
  service:
    tcp: -t ip:port (port&#20026;0&#26102;&#20195;&#34920;&#25152;&#26377;&#31471;&#21475;)
    udp: -u ip:port
    fwm: -f mark&#65292;&#26816;&#27979;&#22312;PREROUTING&#19978;&#30340;&#26631;&#35760;&#65292;&#29992;&#20110;&#21512;&#24182;&#22810;&#20010;&#26381;&#21153;(&#31471;&#21475;)

  -s scheduler: &#40664;&#35748;&#20026;WLC
  -p SCEOND: lvs persistence&#65292;&#35774;&#32622;&#25345;&#32493;&#36830;&#25509;&#26102;&#38388;
</pre>
</div>
</div></li>
<li><a id="orgheadline14"></a>管理集群服务中的RS<br  /><div class="outline-text-5" id="text-orgheadline14">
<div class="org-src-container">

<pre class="src src-conf">ipvsadm -a service -r server-address lvs-type [-w weight]
ipvsadm -d service -r server-address
  server-address: RS&#30340;&#22320;&#22336;&#65292;ip[:port]

  lvs-type:
    -g: GATEWAY, lvs-dr(&#40664;&#35748;)
    -i: IPIP, lvs-tun
    -m: MASQUERADE, lvs-nat

  -w weight: &#35774;&#32622;RS&#30340;&#26435;&#37325;&#65292;&#24403;&#26435;&#37325;&#20026;0&#26102;&#19981;&#20250;&#35843;&#29992;&#35813;RS
</pre>
</div>
</div></li>
<li><a id="orgheadline15"></a>清空和查询<br  /><div class="outline-text-5" id="text-orgheadline15">
<div class="org-src-container">

<pre class="src src-conf">ipvsadm -C  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#28165;&#31354;&#25152;&#26377;&#35268;&#21017;</span>
ipvsadm -L|l [options]  
    -n: numeric&#65292;&#22522;&#20110;&#25968;&#23383;&#26684;&#24335;&#26174;&#31034;&#22320;&#22336;&#21644;&#31471;&#21475;
    -c: connection&#65292;&#26174;&#31034;ipvs&#36830;&#25509;
    --stats: &#32479;&#35745;&#25968;&#25454;
    --rate: &#36895;&#29575;
    --exact: &#31934;&#30830;&#20540;
</pre>
</div>
</div></li>
<li><a id="orgheadline16"></a>保存和重载<br  /><div class="outline-text-5" id="text-orgheadline16">
<div class="org-src-container">

<pre class="src src-conf">ipvsadm -R &lt; FILE
ipvsadm -S [-n] &gt; FILE
</pre>
</div>
</div></li></ul>
</div>
<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18">配置lvs-dr</h4>
<div class="outline-text-4" id="text-orgheadline18">
<ul class="org-ul">
<li>内核参数
<ul class="org-ul">
<li>arp_ignore: 是否响应别人的ARP广播请求
<ul class="org-ul">
<li>0: 检查自己的所有接口的地址</li>
<li>1: 检查同一接口上的地址</li>
</ul></li>
<li>arp_announce: 是否进行ARP通告
<ul class="org-ul">
<li>0: 通告自己所有接口的地址</li>
<li>1: 尽量避免通告不在同一接口的地址</li>
<li>2: 不通告不在同一接口的地址</li>
</ul></li>
</ul></li>
<li><p>
director配置
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #75715E;"># </span><span style="color: #75715E;">ifconfig eno16777736:0 172.16.100.10/32 broadcast 172.16.100.10 up</span>
ip addr add <span style="color: #AE81FF;">172.16.100.10/32</span> dev eno16777736
<span style="color: #75715E;"># </span><span style="color: #75715E;">route add -host 172.16.100.10 dev eno16777736:0</span>
ip route add <span style="color: #AE81FF;">172.16.100.10</span> dev eno16777736

ipvsadm -A -t <span style="color: #AE81FF;">172.16.100.10:80</span>
ipvsadm -a -t <span style="color: #AE81FF;">172.16.100.10:80</span> -r <span style="color: #AE81FF;">172.16.100.21</span> -g
</pre>
</div></li>
<li><p>
RS配置
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #F92672;">echo</span> <span style="color: #AE81FF;">1</span> &gt; /proc/sys/net/ipv4/conf/all/arp_ignore 
<span style="color: #F92672;">echo</span> <span style="color: #AE81FF;">2</span> &gt; /proc/sys/net/ipv4/conf/all/arp_announce 

ifconfig lo:0 <span style="color: #AE81FF;">172.16.100.10/32</span> broadcast <span style="color: #AE81FF;">172.16.100.10</span> up
route add -host <span style="color: #AE81FF;">172.16.100.10</span> dev lo:0
</pre>
</div></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline19" class="outline-4">
<h4 id="orgheadline19">通过FWM定义集群</h4>
<div class="outline-text-4" id="text-orgheadline19">
<ol class="org-ol">
<li><p>
在director上netfilter的mangle表的PREROUTING定义MARK
</p>
<div class="org-src-container">

<pre class="src src-conf">iptables -t mangle -A PREROUTING -d $vip -p $protocol --dports $port -j MARK --set-mark mark_num
</pre>
</div></li>
<li><p>
基于FWM定义集群服务
</p>
<div class="org-src-container">

<pre class="src src-conf">ipvsadm -A -f mark_num -s scheduler
</pre>
</div></li>
</ol>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20">lvs persistence</h4>
<div class="outline-text-4" id="text-orgheadline20">
<p>
lvs持久连接: 无论ipvs使用何种调度方法，其都能实现将来自于同一个Client的请求始终定向至第一次调度时挑选出的RS，通过维护一个持久连接表来实现(SIP RS timer)
</p>
<ul class="org-ul">
<li>持久连接的实现方式
<ul class="org-ul">
<li>每端口持久：PPC，单服务持久调度</li>
<li>每FWM持久：PFWMC，单FWM持久调度</li>
<li>每客户端持久：PCC，所有端口持久调度，定义集群服务时把端口定义为0</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline21" class="outline-4">
<h4 id="orgheadline21">实现调用RS的高可用</h4>
<div class="outline-text-4" id="text-orgheadline21">
<p>
director对RS做健康状态检测，并且根据检测的结果自动完成添加或移除等管理功能
</p>
<ol class="org-ol">
<li>基于协议层次检查: 层次越低，效率越高，精确度越低
<ul class="org-ul">
<li>ip: icmp</li>
<li>传输层：检测端口的开放状态</li>
<li>应用层：请求获取关键性的资源</li>
</ul></li>
<li>检查频度</li>
<li>状态判断: 需要多次检测服务器来确定服务器是否失效</li>
<li>配置一个网页故障时所显示的页面的服务器</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29">HAProxy</h3>
<div class="outline-text-3" id="text-orgheadline29">
</div><div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22">代理服务器相关</h4>
<div class="outline-text-4" id="text-orgheadline22">
<ul class="org-ul">
<li>代理(http)
<ul class="org-ul">
<li>正向代理: 客户端代理</li>
<li>反向代理: 服务器代理</li>
<li>可以在报文上添加Via首部表示代理的服务器</li>
</ul></li>
<li>代理的作用
<ul class="org-ul">
<li>web缓存(加速)</li>
<li>反向代理</li>
<li>内容路由(根据流量及内容类型等将请求转发至特定服务器)</li>
<li>转码器</li>
</ul></li>
<li>缓存的作用
<ul class="org-ul">
<li>减少冗余内容传输</li>
<li>节省带宽、缓解网络瓶颈</li>
<li>降低了对原始服务器的请求压力</li>
<li>降低了传输延迟</li>
</ul></li>
<li>HAProxy的功能
<ul class="org-ul">
<li>http协议反向代理</li>
<li>tcp层的LB</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline23" class="outline-4">
<h4 id="orgheadline23">负载均衡器算法</h4>
<div class="outline-text-4" id="text-orgheadline23">
<ul class="org-ul">
<li>取模法: 无法适应后端服务器个数的改变</li>
<li>一致性hash算法: 使用环形hash来计算，但可能会出现偏斜
<ul class="org-ul">
<li>虚拟服务器: 后端服务器在环上虚拟多个点，使命中平衡</li>
</ul></li>
<li>ebtree: 弹性二叉树</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-4">
<h4 id="orgheadline24">配置</h4>
<div class="outline-text-4" id="text-orgheadline24">
<ul class="org-ul">
<li>配置文件: /etc/haproxy/haproxy.cfg</li>
</ul>
</div>
<ul class="org-ul"><li><a id="orgheadline25"></a>全局配置<br  /><div class="outline-text-5" id="text-orgheadline25">
<div class="org-src-container">

<pre class="src src-conf">global  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#20840;&#23616;&#37197;&#32622;</span>
    log 127.0.0.1 local2  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#37197;&#32622;&#26085;&#24535;&#26381;&#21153;&#22120;&#65292;&#21487;&#37197;&#32622;&#20004;&#20010;</span>
    log-send-hostname [string] <span style="color: #75715E;"># </span><span style="color: #75715E;">&#22312;&#26085;&#24535;&#20013;&#35760;&#24405;&#35813;&#26381;&#21153;&#22120;&#30340;&#20027;&#26426;&#21517;</span>

    chroot /var/lib/haproxy  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#36816;&#34892;&#30340;&#30446;&#24405;&#65292;&#25552;&#39640;&#23433;&#20840;&#24615;</span>
    pidfile /var/run/haproxy.pid
    user haproxy
    group haproxy

    daemon  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#33509;&#19981;&#21152;&#21017;&#36816;&#34892;&#22312;&#21069;&#31471;</span>
    nbproc 1  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#21551;&#21160;&#30340;&#36827;&#31243;&#25968;&#65292;&#40664;&#35748;&#20026;1&#20010;&#65292;&#22810;&#20010;&#19968;&#33324;&#29992;&#20110;&#35843;&#35797;</span>
    maxconn 4000  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#27599;&#20010;&#36827;&#31243;&#30340;&#26368;&#22823;&#36830;&#25509;&#25968;</span>

    spread-checks [0-50] <span style="color: #75715E;"># </span><span style="color: #75715E;">&#20998;&#25955;&#20581;&#24247;&#29366;&#24577;&#26816;&#26597;&#30340;&#21457;&#36865;&#26102;&#38388;</span>
</pre>
</div>
</div></li>
<li><a id="orgheadline26"></a>代理配置<br  /><div class="outline-text-5" id="text-orgheadline26">
<div class="org-src-container">

<pre class="src src-conf">defaults  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#29992;&#20110;&#20026;&#25152;&#26377;&#20854;&#23427;&#37197;&#32622;&#27573;&#25552;&#20379;&#40664;&#35748;&#21442;&#25968;</span>

frontend main  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#23450;&#20041;&#30417;&#21548;&#30340;&#22871;&#25509;&#23383;</span>
    bind *:80
    use_backend
    default_backend websrvs

defaults  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#37325;&#26032;&#35774;&#23450;&#40664;&#35748;&#21442;&#25968;</span>

backend websrvs  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#23450;&#20041;&#21518;&#31471;&#26381;&#21153;&#22120;</span>
    balance roundrobin
    server web1 172.16.100.68 check
    server web2 172.16.100.69 check

listen  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#21516;&#26102;&#23450;&#20041;&#21069;&#31471;&#19982;&#21518;&#31471;</span>
    ...
</pre>
</div>
</div></li>
<li><a id="orgheadline27"></a>代理参数<br  /><div class="outline-text-5" id="text-orgheadline27">
<ol class="org-ol">
<li>balance: 指名调度算法
<ul class="org-ul">
<li>roundrobin: 动态加权轮询，每个后端主机最多接受4128个连接</li>
<li>static-rr: 静态加权轮询，每个后端主机支持的数量无上限</li>
<li>leastconn: 分配给最少连接数的后端，适用于长时间的会话(如SQL、SSH等)</li>
<li>source: 将请求的源地址进行hash运算，并由后端服务器的权重总数相除后派发至某匹配的服务器</li>
<li>uri: 对URI(不包含主机名)的"?"之前的部分进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器</li>
<li>uri_param: 对URI中的指定参数(";"后"?"之前的&lt;param&gt;)的值进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器</li>
<li>hdr(&lt;name&gt;): 对HTTP首部中的参数name的值进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器</li>
</ul></li>
<li>hash-type: 指定算法中的hash算法类型
<ul class="org-ul">
<li>map-based：取模法(静态)，默认配置</li>
<li>consistent：一致性hash算法(动态)</li>
</ul></li>
<li>bind: 指名监听的端口，只能用于frontend, listen</li>
<li>mode {tcp|http}: HAProxy的工作模式，默认为tcp</li>
<li><p>
log: 为每个实例指定log
</p>
<div class="org-src-container">

<pre class="src src-conf">log global
log &lt;address&gt; &lt;facility&gt; [&lt;level&gt; [&lt;minlevel&gt;]]
</pre>
</div></li>
<li>maxconn: 设定指定前端的最大连接数，默认为2000</li>
<li>default_backend: 在没有匹配的"use_backend"规则时为实例指定使用的默认后端</li>
<li><p>
use_backend: 条件式匹配后端
</p>
<div class="org-src-container">

<pre class="src src-conf">use_backend backend if ACL...
</pre>
</div></li>
<li><p>
server: 为backend声明一个server
</p>
<div class="org-src-container">

<pre class="src src-conf">server &lt;name&gt; &lt;addr&gt;[:port] [OPTIONS]
  name: &#29992;&#20110;&#26085;&#24535;&#21644;&#35686;&#21578;

  OPTIONS: 
    backup: &#24403;&#20854;&#20182;&#25152;&#26377;&#26381;&#21153;&#22120;&#19981;&#21487;&#29992;&#26102;&#25165;&#21551;&#21160;&#35813;&#26381;&#21153;&#22120;
    check: &#20581;&#24247;&#29366;&#24577;&#26816;&#27979;
      inter NUM: &#26816;&#27979;&#26102;&#38388;&#38388;&#38548;(&#21333;&#20301;&#20026;ms)&#65292;&#40664;&#35748;&#20026;2000
      fall NUM: server&#20174;&#27491;&#24120;&#29366;&#24577;&#36716;&#25442;&#33267;&#31163;&#32447;&#29366;&#24577;&#38656;&#35201;&#25104;&#21151;&#26816;&#26597;&#30340;&#27425;&#25968;
      rise NUM: server&#20174;&#31163;&#32447;&#29366;&#24577;&#36716;&#25442;&#33267;&#27491;&#24120;&#29366;&#24577;&#38656;&#35201;&#25104;&#21151;&#26816;&#26597;&#30340;&#27425;&#25968;
      port NUM: &#26816;&#27979;&#30340;&#31471;&#21475;
    cookie &lt;value&gt;: &#20026;server&#35774;&#23450;cookie&#65292;&#29992;&#20110;&#23454;&#29616;&#25345;&#20037;&#36830;&#25509;&#30340;&#21151;&#33021;&#65292;&#38656;&#35201;&#21551;&#29992;cookie&#21151;&#33021;
    maxconn NUM: &#27492;&#26381;&#21153;&#25509;&#21463;&#30340;&#24182;&#21457;&#36830;&#25509;&#30340;&#26368;&#22823;&#25968;&#37327;
    maxqueue NUM: &#35831;&#27714;&#38431;&#21015;&#30340;&#26368;&#22823;&#38271;&#24230;
    observe {layer4|layer7}: &#26681;&#25454;&#27969;&#37327;&#21028;&#26029;&#21518;&#31471;server&#30340;&#20581;&#24247;&#29366;&#24577;
    weight: &#25351;&#23450;&#26435;&#37325;&#65292;&#40664;&#35748;&#20026;1&#65292;&#26368;&#22823;&#20026;256&#65292;0&#34920;&#31034;&#19981;&#34987;&#35843;&#24230;
    redir &lt;prefix&gt;: &#37325;&#23450;&#21521;&#65292;&#25152;&#26377;&#21457;&#24448;&#27492;&#26381;&#21153;&#22120;&#30340;&#35831;&#27714;&#22343;&#20197;302&#21709;&#24212;
</pre>
</div></li>
<li><p>
option *chk: 设定后端的健康状态检测方式
</p>
<div class="org-src-container">

<pre class="src src-conf">option httpchk [&lt;method&gt; &lt;uri&gt; &lt;head&gt;]
option tcp-chk
</pre>
</div></li>
<li><p>
cookie: 启用基于cookie的后端服务器绑定，可以实现浏览器绑定
</p>
<div class="org-src-container">

<pre class="src src-conf">cookie &lt;name&gt; insert indirect [OPTIONS]
</pre>
</div></li>
<li><p>
stats: 启用状态监控页
</p>
<div class="org-src-container">

<pre class="src src-conf">listen statistics 
  bind *:9090
  stats enable
  stats hide-version  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#38544;&#34255;&#29256;&#26412;&#21495; </span>
  <span style="color: #75715E;">#</span><span style="color: #75715E;">stats scope .  # &#35774;&#23450;&#20316;&#29992;&#30340;backend</span>
  stats uri /haproxyadmin?stats  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#35775;&#38382;&#36335;&#24452;</span>
  stats realm <span style="color: #E6DB74;">"HAPorxy\ Statistics"</span>  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#26381;&#21153;&#22120;&#25552;&#31034;</span>
  stats auth admin:mageedu  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#23450;&#20041;&#36134;&#21495;&#21644;&#23494;&#30721;</span>
  stats admin if TRUE  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#21551;&#29992;&#31649;&#29702;&#21592;&#21151;&#33021;&#65292;&#21487;&#20197;&#23545;&#21518;&#31471;&#26381;&#21153;&#22120;&#36827;&#34892;&#25805;&#20316;</span>
</pre>
</div></li>
<li><p>
errorfile: 定义错误状态码返回的页面文件，但404需要后端服务器返回
</p>
<div class="org-src-container">

<pre class="src src-conf">errorfile &lt;code&gt; &lt;file&gt;
</pre>
</div></li>
<li><p>
errorloc: 定义错误状态码返回的重定向，但404需要后端服务器返回
</p>
<div class="org-src-container">

<pre class="src src-conf">errorloc &lt;code&gt; &lt;url&gt;  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#20351;&#29992;302&#29366;&#24577;&#30721;&#36827;&#34892;&#36820;&#22238;</span>
errorloc303 &lt;code&gt; &lt;url&gt;  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#20351;&#29992;303&#29366;&#24577;&#30721;&#36827;&#34892;&#36820;&#22238;</span>
</pre>
</div></li>
<li><p>
capture: 捕获指定参数最近一次出现的第一个值，记录在日志中
</p>
<div class="org-src-container">

<pre class="src src-conf">capture request header &lt;name&gt; len &lt;length&gt;  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#25429;&#33719;&#35831;&#27714;&#25253;&#25991;</span>
capture response header &lt;name&gt; len &lt;length&gt;  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#25429;&#33719;&#21709;&#24212;&#25253;&#25991;</span>
</pre>
</div></li>
<li>option httplog: 记录更详细的日志信息</li>
<li>option logasap: 在HTTP请求处理记录日志，默认是HTTP请求结束后才记录日志，但无法记录传输字节数</li>
<li><p>
option forwardfor: 允许在发往服务器的请求首部中插入"X-Forwarded-For"首部，记录客户端地址，用于后端的日志记录
</p>
<div class="org-src-container">

<pre class="src src-conf">option forwardfor [ except &lt;network&gt; ] [ header &lt;name&gt; ] [ if-none ]
</pre>
</div></li>
<li><p>
http_request: 用于定义访问控制
</p>
<div class="org-src-container">

<pre class="src src-conf">http_request allow if ACL...
http_request deny  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#23450;&#20041;&#40664;&#35748;&#35268;&#21017;</span>
</pre>
</div></li>
<li>option http-server-close: 打开与客户端保持连接的断开功能</li>
<li>option http-pretend-keepalive: 打开与后端的保持连接功能</li>
<li><p>
redirect: 重定向访问地址
</p>
<div class="org-src-container">

<pre class="src src-sh">redirect prefix https://www.qiump.com if ACL...  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#37325;&#23450;&#21521;&#20027;&#26426;&#22320;&#22336;&#21644;&#21327;&#35758;</span>
redirect location / clear-cookie <span style="color: #FD971F;">USERID</span>= if logout  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#37325;&#23450;&#21521;&#39029;&#38754;&#21644;&#28165;&#38500;cookie</span>
</pre>
</div></li>
<li><p>
reqadd/rspadd: 添加请求或响应报文首部
</p>
<div class="org-src-container">

<pre class="src src-conf">reqadd &lt;string&gt; [if ACL...] 
rspadd &lt;string&gt; [if ACL...]
</pre>
</div></li>
<li><p>
timeout: 定义各种超时时长
</p>
<div class="org-src-container">

<pre class="src src-conf">timeout http-request    10s
timeout queue           1m
timeout connect         10s
timeout client          1m
timeout server          1m
timeout http-keep-alive 10s
timeout check           10s
</pre>
</div></li>
</ol>
</div></li>
<li><a id="orgheadline28"></a>ACL测试条件<br  /><div class="outline-text-5" id="text-orgheadline28">
<div class="org-src-container">

<pre class="src src-conf">acl &lt;aclname&gt; &lt;criterion&gt; [-i] [operator] &lt;value&gt; ...
  aclname: &#23450;&#20041;ACL&#30340;&#21517;&#23383;&#65292;&#21487;&#20197;&#37325;&#22797;(&#34920;&#31034;&#21512;&#24182;)
  criterion: &#26816;&#26597;&#26465;&#20214;
  -i: &#21305;&#37197;&#24573;&#30053;&#22823;&#23567;&#20889;
  operator: eq&#12289;ge&#12289;gt&#12289;le&#12289;lt&#65292;&#29992;&#20110;&#25968;&#20540;&#30340;&#27604;&#36739;
  value: &#21487;&#20351;&#29992;&#25972;&#25968;&#33539;&#22260;(1024:65535)&#12289;&#23383;&#31526;&#20018;&#12289;&#27491;&#21017;&#34920;&#36798;&#24335;&#12289;&#32593;&#32476;&#22320;&#22336;
</pre>
</div>
<ul class="org-ul">
<li>测试条件criterion
<ol class="org-ol">
<li><p>
be_sess_rate(backend) &lt;int&gt;: 测试backend的会话创建速率，一般用于阻止攻击行为
</p>
<div class="org-src-container">

<pre class="src src-conf">acl being_scanned be_sess_rate gt 50
redirect location /error_pages/denied.html if being_scanned
</pre>
</div></li>
<li><p>
fe_sess_rate &lt;int&gt;: 测试frontend的会话创建速率
</p>
<div class="org-src-container">

<pre class="src src-conf">acl too_fast fe_sess_rate ge 50
tcp-request inspect-delay 500ms
tcp-request content accept if ! too_fast  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#27979;&#35797;&#36895;&#29575;</span>
tcp-request content accept if WAIT_END  <span style="color: #75715E;"># </span><span style="color: #75715E;">WAIT_END&#34920;&#31034;&#24310;&#36831;&#26102;&#38388;&#26159;&#21542;&#21040;&#36798;</span>
</pre>
</div></li>
<li>测试请求的路径
<ul class="org-ul">
<li>path_beg &lt;str&gt;: 测试请求的路径是否以&lt;str&gt;指定的模式开头</li>
<li>path_end &lt;str&gt;: 测试请求的路径是否以&lt;str&gt;指定的模式结尾</li>
<li>path_reg &lt;str&gt;: 对路径进行正则匹配</li>
</ul></li>
<li>测试请求的URL
<ul class="org-ul">
<li>url_beg &lt;str&gt;</li>
<li>url_end &lt;str&gt;</li>
<li>url_reg</li>
</ul></li>
<li>method &lt;str&gt;: 测试HTTP请求报文中使用的方法</li>
<li>测试请求报文的首部
<ul class="org-ul">
<li>hdr(header) &lt;str&gt;: 测试请求报文中的所有首部或指定首部是否满足指定的条件</li>
<li>hdr_beg(header) &lt;str&gt;</li>
<li>hdr_end(header) &lt;str&gt;</li>
</ul></li>
</ol></li>
<li>多个测试条件可以用逻辑操作符进行组合，如"||"、"!"，默认为"与"</li>
</ul>
</div></li></ul>
</div>
</div>
</div>
