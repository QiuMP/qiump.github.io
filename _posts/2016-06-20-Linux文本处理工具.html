---
title: "Linux文本处理工具"
date: 2016-06-20
layout: post
categories: 
- Linux
tags: 
- Linux 
- 运维 
- 文本处理
published: true
comments: 
---
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">1. head, tail</a></li>
<li><a href="#orgheadline2">2. tr</a></li>
<li><a href="#orgheadline3">3. wc</a></li>
<li><a href="#orgheadline4">4. cut</a></li>
<li><a href="#orgheadline5">5. sort</a></li>
<li><a href="#orgheadline6">6. uniq</a></li>
<li><a href="#orgheadline7">7. grep</a></li>
<li><a href="#orgheadline8">8. sed</a></li>
<li><a href="#orgheadline9">9. gawk</a></li>
</ul>
</div>
</div>
<p>
介绍了Linux下常用的文本处理工具，包括head, tail, tr, wc, cut, sort, uniq，以及文本处理三剑客grep, sed, awk
</p>




<hr  />
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1"><span class="section-number-2">1</span> head, tail</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-conf">head [OPTION]... [FILE]...  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#35835;&#21462;&#25991;&#20214;&#22836;</span>
  -c num: &#25351;&#23450;&#33719;&#21462;&#21069;num&#23383;&#33410;
  -n num/-num: &#25351;&#23450;&#33719;&#21462;&#21069;num&#34892;
  -n -num: &#25490;&#38500;&#21518;num&#34892;
</pre>
</div>
<div class="org-src-container">

<pre class="src src-conf">tail [OPTION]... [FILE]...  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#35835;&#21462;&#25991;&#20214;&#23614;</span>
  -c num: &#25351;&#23450;&#33719;&#21462;&#21518;num&#23383;&#33410;
  -n num/-num: &#25351;&#23450;&#33719;&#21462;&#21518;num&#34892;
  -n +num: &#25490;&#38500;&#31532;num&#34892;&#20043;&#21069;&#30340;&#34892;&#25968;
  -f: &#36319;&#36394;&#26174;&#31034;&#25991;&#20214;&#26032;&#36861;&#21152;&#30340;&#20869;&#23481;&#65307;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2"><span class="section-number-2">2</span> tr</h2>
<div class="outline-text-2" id="text-2">
<p>
转换或删除字符
</p>
<div class="org-src-container">

<pre class="src src-conf">tr [OPTION]... SET1 [SET2]
  -d: &#21024;&#38500;SET1&#20013;&#30340;&#23383;&#31526;(&#40664;&#35748;&#20026;&#36716;&#25442;&#20026;SET2&#23545;&#24212;&#30340;&#23383;&#31526;)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3"><span class="section-number-2">3</span> wc</h2>
<div class="outline-text-2" id="text-3">
<p>
行数 单词 字节
</p>
<div class="org-src-container">

<pre class="src src-conf">wc [OPTION]... [FILE]...
  -l: lines
  -w: words
  -c: characters

wc -l FILE | cut -d<span style="color: #E6DB74;">' '</span> -f1  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#32479;&#35745;&#25991;&#20214;&#30340;&#34892;&#25968;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4"><span class="section-number-2">4</span> cut</h2>
<div class="outline-text-2" id="text-4">
<p>
通过分隔符切割后显示指定字段
</p>
<div class="org-src-container">

<pre class="src src-conf">cut [OPTION]... [FILE]...
  -d DELIMITER: &#25351;&#23450;&#20998;&#38548;&#31526;(&#40664;&#35748;&#20026;&#21046;&#34920;&#31526;)
  -f FILEDS: &#25351;&#23450;&#23383;&#27573;&#65292;&#22914; 1-3,7
  <span style="color: #FD971F;">--output-delimiter</span>=STRING: &#25351;&#23450;&#36755;&#20986;&#20998;&#38548;&#31526;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><span class="section-number-2">5</span> sort</h2>
<div class="outline-text-2" id="text-5">
<p>
排序
</p>
<div class="org-src-container">

<pre class="src src-conf">sort [OPTION]... [FILE]...
  -f: &#24573;&#30053;&#23383;&#31526;&#22823;&#23567;&#20889;
  -r: &#36870;&#24207;
  -t DELIMITER: &#23383;&#27573;&#20998;&#38548;&#31526;
  -k num: &#20197;&#25351;&#23450;&#23383;&#27573;&#20026;&#26631;&#20934;&#25490;&#24207;
  -n: &#20197;&#25968;&#20540;&#22823;&#23567;&#36827;&#34892;&#25490;&#24207;
  -u: uniq&#65292;&#25490;&#24207;&#21518;&#21435;&#37325;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6"><span class="section-number-2">6</span> uniq</h2>
<div class="outline-text-2" id="text-6">
<p>
去除连续且完全相同的行
</p>
<div class="org-src-container">

<pre class="src src-conf">uniq [OPTION]... [FILE]...
  -c: &#26174;&#31034;&#27599;&#34892;&#37325;&#22797;&#20986;&#29616;&#30340;&#27425;&#25968;&#65307;
  -d: &#20165;&#26174;&#31034;&#37325;&#22797;&#36807;&#30340;&#34892;&#65307;
  -u: &#20165;&#26174;&#31034;&#19981;&#26366;&#37325;&#22797;&#30340;&#34892;&#65307;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7"><span class="section-number-2">7</span> grep</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>grep是一个文本过滤工具，根据用户指定的“模式pattern”对目标文本逐行进行匹配检查，打印匹配到的行</li>
<li>grep工具有三种: 
<ul class="org-ul">
<li>grep支持基础正则表达式</li>
<li>egrep相当于 <code>grep -E</code> ，用于扩展正则表达式</li>
<li>fgrep不支持正则表达时，但匹配速度快</li>
</ul></li>
</ul>
<div class="org-src-container">

<pre class="src src-conf">grep [OPTIONS] PATTERN [FILE...]
  -E: &#20351;&#29992;&#25193;&#23637;&#27491;&#21017;&#34920;&#36798;&#24335;ERE

  -v: &#26174;&#31034;&#19981;&#33021;&#22815;&#34987;pattern&#21305;&#37197;&#21040;&#30340;&#34892;
  -i: ignore &#24573;&#30053;&#23383;&#31526;&#22823;&#23567;&#20889;
  -o: only &#20165;&#26174;&#31034;&#21305;&#37197;&#21040;&#30340;&#23383;&#31526;&#20018;
  -q: quite &#38745;&#40664;&#27169;&#24335;&#65292;&#19981;&#36755;&#20986;&#20219;&#20309;&#20449;&#24687;(&#21518;&#36793;&#21487;&#20197;&#26816;&#26597;$?&#26469;&#26816;&#26597;&#26159;&#21542;&#21305;&#37197;&#21040;)

  -r: &#21516;&#26102;&#25628;&#32034;&#30446;&#24405;&#30340;&#23376;&#30446;&#24405;

  -A num: after, &#21305;&#37197;&#30340;&#34892;&#21516;&#26102;&#26174;&#31034;&#20854;&#21518;num&#34892;
  -B num: before, &#21305;&#37197;&#30340;&#34892;&#21516;&#26102;&#26174;&#31034;&#20854;&#21069;num&#34892;
  -C num: context, &#21305;&#37197;&#30340;&#34892;&#21516;&#26102;&#26174;&#31034;&#20854;&#21069;&#21518;num&#34892;

  <span style="color: #FD971F;">--color</span>=auto: &#23545;&#21305;&#37197;&#21040;&#30340;&#25991;&#26412;&#30528;&#33394;&#26174;&#31034;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8"><span class="section-number-2">8</span> sed</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>sed: Stream EDitor，是一个行编辑器</li>
<li>sed有两个缓存空间：模式空间和保持空间</li>
<li>sed每次读取文件的一行到模式空间中处理，结束时将模式空间的内容输出至屏幕</li>
</ul>
<div class="org-src-container">

<pre class="src src-conf">sed [option]... <span style="color: #E6DB74;">'script'</span> inputfile...
  -n: &#19981;&#36755;&#20986;&#27169;&#24335;&#31354;&#38388;&#20013;&#30340;&#20869;&#23481;&#33267;&#23631;&#24149;
  -e: &#22810;&#28857;&#32534;&#36753;
  -f /PATH/TO/SCRIPT_FILE: &#20174;&#25351;&#23450;&#25991;&#20214;&#20013;&#35835;&#21462;&#32534;&#36753;&#33050;&#26412;
  -r: &#25903;&#25345;&#20351;&#29992;&#25193;&#23637;&#27491;&#21017;&#34920;&#36798;&#24335;
  -i: &#21407;&#25991;&#20214;&#32534;&#36753;

  script&#26684;&#24335;: &#22320;&#22336;+&#21629;&#20196;&#65292;&#22810;&#26465;&#21629;&#20196;&#29992;;&#38548;&#24320;&#65292;&#21629;&#20196;&#21487;&#20197;&#20351;&#29992;{}&#25324;&#36215;&#22810;&#26465;&#21629;&#20196;
</pre>
</div>
<ul class="org-ul">
<li>地址定界
<ol class="org-ol">
<li>不给地址：对全文进行处理</li>
<li>单地址：
<ul class="org-ul">
<li>#: 指定的行</li>
<li>/pattern/：被此处模式所能够匹配到的每一行</li>
</ul></li>
<li>地址范围：
<ul class="org-ul">
<li><code>#,#</code></li>
<li><code>#,+#</code></li>
<li><code>/pat1/,/pat2/</code></li>
<li><code>#,/pat1/</code></li>
</ul></li>
<li>~：步进 (first~step)</li>
</ol></li>
<li>编辑命令
<ul class="org-ul">
<li>!: 取反条件，放在编辑命令之前</li>
<li>d: 删除</li>
<li>p: 显示模式空间中的内容(一般配合-n使用)</li>
<li>a \text：在行后面追加新行(支持使用\n实现多行追加)</li>
<li>i \text：在行前面插入文本(支持使用\n实现多行插入)</li>
<li>c \text：替换行(同时替换地址范围所有行)为单行或多行文本</li>
<li>w /path/to/somefile: 保存模式空间匹配到的行至指定文件中</li>
<li>r /path/from/somefile：读取指定文件的文本流至模式空间中匹配到的行的行后</li>
<li>=: 为模式空间中的行打印行号</li>
<li>l: 打印行中的特殊字符</li>
<li>y/inchars/outchars/: 转换命令，对inchars中的字符替换成outchars对应的字符</li>
<li>s///NUM：查找替换第NUM个(默认为1)匹配
<ul class="org-ul">
<li>替换内容中使用 &amp; 来代表所匹配的内容</li>
<li>替换标记
<ul class="org-ul">
<li>g: 行内全局替换</li>
<li>p: 显示替换成功的行</li>
<li>w /PATH/TO/SOMEFILE：将替换成功的结果保存至指定文件中</li>
</ul></li>
</ul></li>
</ul></li>
<li>高级编辑命令
<ul class="org-ul">
<li>h: 把模式空间中的内容覆盖至保持空间中</li>
<li>H：把模式空间中的内容追加至保持空间中</li>
<li>g: 从保持空间取出数据覆盖至模式空间</li>
<li>G：从保持空间取出内容追加至模式空间</li>
<li>x: 把模式空间中的内容与保持空间中的内容进行互换</li>
<li>n: 输出模式空间的内容，读取匹配到的行的下一行至模式空间</li>
<li>N：追加匹配到的行的下一行至模式空间，若到没有下一行可读，则立即停止程序</li>
<li>d: 删除模式空间中的所有行</li>
<li>D：删除模式空间中的第一行，即删除到第一个换行符</li>
</ul></li>
<li>改变流
<ul class="org-ul">
<li>D: D命令删除第一行后会强制sed返回脚本顶部，而不读取新的行</li>
<li><p>
b [label]: 跳转到label标签的位置，若省略则跳转到脚本结尾
</p>
<ul class="org-ul">
<li>标签的位置通过 <code>:label</code> 来指定</li>
</ul>
<div class="org-src-container">

<pre class="src src-sh">:start
s/,//1p
/,/b start  <span style="color: #75715E;"># </span><span style="color: #75715E;">&#20351;&#29992;&#22320;&#22336;&#27169;&#24335;&#36991;&#20813;&#27515;&#24490;&#29615;</span>
</pre>
</div></li>
<li>t [label]: 检查最近一次替换是否成功，成功则跳转到标签位置或脚本结尾，失败则继续执行脚本</li>
<li>T [label]: 检查最近一次替换是否失败，失败则跳转到标签位置或脚本结尾，成功则继续执行脚本</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9"><span class="section-number-2">9</span> gawk</h2>
<div class="outline-text-2" id="text-9">
<ul class="org-ul">
<li>文本报告生成器，用于格式化文本输出</li>
<li>Linux下的awk也是gawk的链接文件</li>
<li>gawk每次读取文件的一行到模式空间中处理，根据字段分隔符进行切割</li>
</ul>
<div class="org-src-container">

<pre class="src src-conf">gawk [options] <span style="color: #E6DB74;">'program'</span> FILE...
  -F: &#25351;&#26126;&#36755;&#20837;&#26102;&#29992;&#21040;&#30340;&#23383;&#27573;&#20998;&#38548;&#31526;(&#40664;&#35748;&#20026;&#31354;&#30333;&#23383;&#31526;&#65292;&#19981;&#21516;&#20110;cut)&#65292;&#21487;&#20197;&#29992;[%:]&#25351;&#23450;&#22810;&#20010;&#20998;&#38548;&#31526;
  -f FILE: &#20174;FILE&#20013;&#35835;&#21462;program
  <span style="color: #FD971F;">-v var</span>=value: &#33258;&#23450;&#20041;&#21464;&#37327;

  program: PATTERN{ACTION}
</pre>
</div>
<ul class="org-ul">
<li>字段
<ul class="org-ul">
<li>$0: 当前处理的内容</li>
<li>$1,$2,&#x2026;: 第n个字段</li>
</ul></li>
<li>变量(引用变量时不需要用$)
<ul class="org-ul">
<li>内建变量
<ul class="org-ul">
<li>FS：input field seperator，默认为空白字符</li>
<li>OFS：output field seperator，默认为空白字符</li>
<li>RS：input record seperator，输入时的行分隔符</li>
<li>ORS：output record seperator，输出时的行分隔符</li>
<li>NF：number of field，当前行字段数量
<ul class="org-ul">
<li>$NF为最后一个字段的内容</li>
</ul></li>
<li>NR：number of record, 当前已处理的行数</li>
<li>FNR：当前文件已处理的行数</li>
<li>FILENAME：当前文件名</li>
<li>ARGC：命令行参数的个数</li>
<li>ARGV[n]：保存命令行所给定的各参数的数组</li>
</ul></li>
<li>自定变量
<ul class="org-ul">
<li>使用 <code>-v var=value</code></li>
<li>在program中直接定义</li>
</ul></li>
</ul></li>
<li>数组
<ul class="org-ul">
<li>awk支持关联数组: array["yes"]</li>
<li>在引用时，如果某数组元素事先不存在，awk会自动创建此元素，并将其值初始化为"空串"</li>
<li>判断数组中是否存在某元素，使用 <code>index in array</code></li>
</ul></li>
<li>操作符
<ul class="org-ul">
<li>算数操作符: <code>+,-,*,/,**,%</code></li>
<li>赋值操作符: =,+=,-+,*=,/=,%=,^=,++,&#x2013;
<ul class="org-ul">
<li>空字符串计算时会被视作0</li>
</ul></li>
<li>比较操作符: &gt;,&gt;=,&lt;,&lt;=,!=,==</li>
<li>模式匹配符:
<ul class="org-ul">
<li>~: 是否匹配
<ul class="org-ul">
<li>例如 <code>$NF~/bash$/</code> 匹配最后一个字段是否以bash结尾</li>
</ul></li>
<li>!~: 是否不匹配</li>
</ul></li>
<li>逻辑操作符: &amp;&amp;,||,!</li>
<li>三元操作符: CONDITION?if-true-expression:if-false-expression</li>
<li>函数调用: FNAME(argu1,argu2&#x2026;)</li>
</ul></li>
<li>PATTERN
<ol class="org-ol">
<li>empty: 空模式，匹配每一行</li>
<li><code>/regular/</code>: 仅处理能够被此处的模式匹配到的行</li>
<li><code>!/regular/</code>: 仅处理不能够被此处的模式匹配到的行</li>
<li><code>/pat1/,/pat2/</code>: 从pat1匹配的行到pat2匹配的行</li>
<li>关系表达式: 结果为真时(非0值或非空字符)才会被处理，若有多个判断则用括号括起来</li>
<li>BEGIN: 仅在开始处理文件中的文本之前执行一次，可在里边定义分隔符</li>
<li>END: 仅在文本处理完成之后执行一次</li>
</ol></li>
<li>输出
<ul class="org-ul">
<li><p>
print
</p>
<div class="org-src-container">

<pre class="src src-conf">print item1, item2, ...
</pre>
</div>
<ul class="org-ul">
<li>分隔符要使用逗号，若使用空格则会被连接起来显示</li>
<li>输出的item可以是字符串(用双引号括起)、数值，也可以是当前记录的字段、变量或awk的表达式(不能用双引号括起来)</li>
<li>如果省略item, 相当于 <code>print $0</code></li>
<li>print每句会自动换行</li>
</ul></li>
<li><p>
printf
</p>
<div class="org-src-container">

<pre class="src src-conf">printf FORMAT, item1, ...
  &#26684;&#24335;&#31526;
    %c: &#26174;&#31034;&#23383;&#31526;&#30340;ASCII&#30721;
    %d, %i: &#26174;&#31034;&#21313;&#36827;&#21046;&#25972;&#25968;
    %e, %E: &#31185;&#23398;&#35745;&#25968;&#27861;&#25968;&#20540;&#26174;&#31034;
    %f: &#26174;&#31034;&#20026;&#28014;&#28857;&#25968;
    %g, %G: &#20197;&#31185;&#23398;&#35745;&#25968;&#27861;&#25110;&#28014;&#28857;&#24418;&#24335;&#26174;&#31034;&#25968;&#20540;
    %s: &#26174;&#31034;&#23383;&#31526;&#20018;
    %u: &#26080;&#31526;&#21495;&#25972;&#25968;
    %%: &#26174;&#31034;%&#33258;&#36523;
  &#20462;&#39280;&#31526;
    *[.*]: &#31532;&#19968;&#20010;&#25968;&#23383;&#25511;&#21046;&#26174;&#31034;&#30340;&#23485;&#24230;&#65292;&#31532;&#20108;&#20010;*&#34920;&#31034;&#23567;&#25968;&#28857;&#21518;&#30340;&#31934;&#24230;&#65292;&#20363;&#22914; %3.1f
    -: &#24038;&#23545;&#40784;
    +: &#26174;&#31034;&#25968;&#20540;&#30340;&#31526;&#21495;
</pre>
</div></li>
</ul></li>
<li>控制语句
<ul class="org-ul">
<li><code>if(condition) {statments}</code></li>
<li><code>if(condition) {statments} else {statements}</code></li>
<li><code>switch(expression) {case VALUE1 or /REGEXP/: statement; ...; default: statement}</code></li>
<li><code>while(conditon) {statments}</code></li>
<li><code>do {statements} while(condition)</code></li>
<li><code>for(expr1;expr2;expr3) {statements}</code></li>
<li><code>for(var in array) {statements}</code>: var会遍历array的每个索引</li>
<li><code>break [n]</code></li>
<li><code>continue [n]</code></li>
<li><code>delete array[index]</code>: 删除数组中的指定元素</li>
<li><code>delete array</code></li>
<li><code>netx</code>: 提前结束对本行的处理而直接进入下一行</li>
<li><code>exit [n]</code>: 马上执行END块后结束awk，如果已经在END块中则退出状态码为n</li>
</ul></li>
<li>函数
<ul class="org-ul">
<li>常用内置函数
<ul class="org-ul">
<li>rand(): 返回0到1之间的一个随机数</li>
<li>length([s])：返回指定字符串的长度</li>
<li>sub(r,s,[t])：以r表示的模式来查找t所表示的字符中的匹配的内容，并将其第一次出现替换为s所表示的内容</li>
<li>gsub(r,s,[t])：以r表示的模式来查找t所表示的字符中的匹配的内容，并将其所有出现均替换为s所表示的内容</li>
<li>split(s,a[,r])：以r为分隔符切割字符s，并将切割后的结果保存至a所表示的数组中</li>
</ul></li>
<li>自定义函数
<ul class="org-ul">
<li>function name(argu,&#x2026;){statments}</li>
<li>自定义函数需要放在所有代码块(包括BEGIN代码块)之前</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
