#+TITLE: HA Cluster
#+DATE: 2016-07-24
#+SETUPFILE: ~/myblog/setupfile.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: Linux
#+JEKYLL_TAGS: Linux 运维 网络
#+JEKYLL_PUBLISHED: true

TODO




-----
* Cluster
** 系统扩展方式
- scale up: 向上扩展，使用性能更好的主机
- scale out: 向外扩展，使用更多的主机
** 集群类型
- LB(Load Balancing)：负载均衡集群，任务分配
  - 基于软硬件划分
    - 硬件: F5、NetScaler、A10、Array、Redware
    - 软件: LVS、HAProxy、Nginx、ats、perlbal
  - 基于工作的协议层次划分
    - 传输层：lvs, haproxy(mode tcp)
    - 应用层：haproxy, nginx, ats, perlbal
- HA(High Availability)：高可用集群，系统快速修复
  - Availability=可用时间/总时间
  - vrrp: keepalived
  - AIS: heartbeat, OpenAIS, corosync/pacemaker, cman/rgmanager(conga)
- HP(High Performancing)：高性能集群，并行处理、分布式
  - 分布式应用
  - 分布式静态资源
  - 分布式数据和存储
  - 分布式计算
** 衡量系统的指标
- 可扩展性
  - 构建高可扩展性系统的重要原则：在系统内部尽量避免串行化和交互
- 可用性
- 容量: 请求处理的最大量
- 吞吐量: 单位时间的请求处理量
- 性能: 请求处理时间
** 高效运维
可用 --> 标准化 --> 自动化
** session保持
- session绑定：基于cookie进行绑定
- session集群：解决所有主机的session的同步问题
- session服务器：解决session的可用性，可使用memcached、redis
** 术语
- 调度器(负载均衡器)：director, dispatcher, balancer
- RS: Real Server
- Client IP: CIP
- Director Virutal IP: VIP
- Director IP: DIP
- Real Server IP: RIP
* LB集群
** lvs
lvs: Linux Virtual Server，根据请求报文的目标IP和PORT将其转发至后端主机集群中的某一台主机(根据挑选算法)，支持TCP, UDP, AH, ESP, AH_ESP, SCTP等诸多协议
*** lvs组件
- ipvsadm: 用户空间的命令行工具，用于管理集群服务
- ipvs: 工作内核中netfilter INPUT钩子上，报文传输线路为PREROUTING --> INPUT --> POSTROUTING
*** lvs类型
- lvs-nat :: 多目标的DNAT，它通过修改请求报文的目标IP地址(同时可能会修改目标端口)至某RS的RIP地址实现转发
  1. RIP和DIP应该使用私网地址，且RS的网关要指向DIP
  2. 请求和响应报文都要经由director转发，在极高负载的场景中，director可能会成为系统瓶颈
  3. 支持端口映射
  4. RS可以使用任意OS
- lvs-dr :: direct routing(默认)，它通过修改请求报文的目标MAC地址进行转发，仅请求报文经由director，响应报文是由RS直接响应给Client
  1. Driector使用VIP、DIP；RS使用RIP、VIP
  2. 保证前端路由器将目标IP为VIP的请求报文发送给director，可以通过路由静态绑定、使用arptables使RS拒绝响应、直接修改RS主机内核的参数
  3. RS的RIP可以使用私有地址；但也可以使用公网地址
  4. RS跟Director必须在同一物理网络中
  5. 请求报文经由Director调度，但响应报文一定不能经由Director
  6. 不支持端口映射
  7. RS可以大多数OS
  8. RS通过地址为VIP的lo设备进行操作
  9. RS的网关不能指向DIP，应指向外网路由
- lvs-tun :: 不修改请求报文的IP首部，而是通过在原有的IP首部(CIP,VIP)之外，再封装一个IP首部(DIP,RIP)
  1. RIP、DIP、VIP都是公网地址
  2. RS通过地址为VIP的lo设备接受和发送报文
  3. 请求报文必须经由director调度，但响应报文必须不能经由director
  4. 不支持端口映射
  5. RS的OS必须支持隧道功能
  6. 必要时需要限制请求报文的MTU大小
- lvs-fullnat :: director通过同时修改请求报文的目标地址和源地址进行转发，需要使用淘宝开源项目进行支持
  1) VIP是公网地址；RIP和DIP是私网地址，二者无须在同一网络中
  2) RS接收到的请求报文的源地址为DIP
  3) 请求报文和响应报文都必须经由Director
  4) 支持端口映射机制
  5) RS可以使用任意OS
*** lvs scheduler
scheduler是Director通过算法来选择要调度的RS
- 静态方法: 仅根据算法本身进行调度
  - RR(round robin): 轮调
  - WRR(weighted rr): 按照权重分配
  - SH(source hash): 将来自于同一个IP的请求始终调度至同一RS，实现session保持的机制，但只适用于同个端口
  - DH(destination hash): 将对同一个目标的请求始终发往同一个RS，对于新目标使用轮调分配，用于正向代理情形下的缓存服务器调度
- 动态方法: 根据算法计算各RS的当前负载状态(Overhead)进行调度，其中Active是活动连接数，Inactive是非活动连接数
  - LC(Least Connection): Overhead=Active*256+Inactive
  - WLC(Weighted LC): Overhead=(Active*256+Inactive)/weight
  - SED(Shortest Expection Delay): Overhead=(Active+1)*256/weight，解决WLC下0连接数时的分配
  - NQ(Never Queue): SED算法的改进，优先分配给0连接数的RS
  - LBLC(Locality-Based LC): 动态的DH算法，对于新目标使用LC分配，用于正向代理情形下的缓存服务器调度
  - LBLCR(Locality-Based Least-Connection with Replication): 带复制功能的LBLC算法
*** lvs架构
1. 一个ipvs主机可以同时定义多个cluster service
2. 一个cluster service上至少应该一个real server
*** ipvsadm的用法
**** 管理集群服务
#+BEGIN_SRC conf
ipvsadm -A|-E service [-s scheduler] [-p SECOND] # APPEND
ipvsadm -D service  # DELETE
  service:
    tcp: -t ip:port (port为0时代表所有端口)
    udp: -u ip:port
    fwm: -f mark，检测在PREROUTING上的标记，用于合并多个服务(端口)

  -s scheduler: 默认为WLC
  -p SCEOND: lvs persistence，设置持续连接时间
#+END_SRC
**** 管理集群服务中的RS
#+BEGIN_SRC conf
ipvsadm -a service -r server-address lvs-type [-w weight]
ipvsadm -d service -r server-address
  server-address: RS的地址，ip[:port]

  lvs-type:
    -g: GATEWAY, lvs-dr(默认)
    -i: IPIP, lvs-tun
    -m: MASQUERADE, lvs-nat

  -w weight: 设置RS的权重，当权重为0时不会调用该RS
#+END_SRC
**** 清空和查询
#+BEGIN_SRC conf
ipvsadm -C  # 清空所有规则
ipvsadm -L|l [options]	
	-n: numeric，基于数字格式显示地址和端口
	-c: connection，显示ipvs连接
	--stats: 统计数据
	--rate: 速率
	--exact: 精确值		
#+END_SRC
**** 保存和重载
#+BEGIN_SRC conf
ipvsadm -R < FILE
ipvsadm -S [-n] > FILE
#+END_SRC
*** 配置lvs-dr
- 内核参数
  - arp_ignore: 是否响应别人的ARP广播请求
    - 0: 检查自己的所有接口的地址
    - 1: 检查同一接口上的地址
  - arp_announce: 是否进行ARP通告
    - 0: 通告自己所有接口的地址
    - 1: 尽量避免通告不在同一接口的地址
    - 2: 不通告不在同一接口的地址
- director配置
  #+BEGIN_SRC sh
  # ifconfig eno16777736:0 172.16.100.10/32 broadcast 172.16.100.10 up
  ip addr add 172.16.100.10/32 dev eno16777736
  # route add -host 172.16.100.10 dev eno16777736:0
  ip route add 172.16.100.10 dev eno16777736
  
  ipvsadm -A -t 172.16.100.10:80
  ipvsadm -a -t 172.16.100.10:80 -r 172.16.100.21 -g
  #+END_SRC
- RS配置
  #+BEGIN_SRC sh
  echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore 
  echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce 

  ifconfig lo:0 172.16.100.10/32 broadcast 172.16.100.10 up
  route add -host 172.16.100.10 dev lo:0
  #+END_SRC
*** 通过FWM定义集群
1. 在director上netfilter的mangle表的PREROUTING定义MARK
   #+BEGIN_SRC conf
   iptables -t mangle -A PREROUTING -d $vip -p $protocol --dports $port -j MARK --set-mark mark_num
   #+END_SRC
2. 基于FWM定义集群服务
   #+BEGIN_SRC conf
   ipvsadm -A -f mark_num -s scheduler
   #+END_SRC
*** lvs persistence
lvs持久连接: 无论ipvs使用何种调度方法，其都能实现将来自于同一个Client的请求始终定向至第一次调度时挑选出的RS，通过维护一个持久连接表来实现(SIP RS timer)
- 持久连接的实现方式
  - 每端口持久：PPC，单服务持久调度
  - 每FWM持久：PFWMC，单FWM持久调度
  - 每客户端持久：PCC，所有端口持久调度，定义集群服务时把端口定义为0
*** 实现调用RS的高可用
director对RS做健康状态检测，并且根据检测的结果自动完成添加或移除等管理功能
1. 基于协议层次检查: 层次越低，效率越高，精确度越低
   - ip: icmp
   - 传输层：检测端口的开放状态
   - 应用层：请求获取关键性的资源
2. 检查频度
3. 状态判断: 需要多次检测服务器来确定服务器是否失效
4. 配置一个网页故障时所显示的页面的服务器
** HAProxy
*** 代理服务器相关
- 代理(http)
  - 正向代理: 客户端代理
  - 反向代理: 服务器代理
  - 可以在报文上添加Via首部表示代理的服务器
- 代理的作用
  - web缓存(加速)
  - 反向代理
  - 内容路由(根据流量及内容类型等将请求转发至特定服务器)
  - 转码器
- 缓存的作用
  - 减少冗余内容传输
  - 节省带宽、缓解网络瓶颈
  - 降低了对原始服务器的请求压力
  - 降低了传输延迟
- HAProxy的功能
  - http协议反向代理
  - tcp层的LB
*** 负载均衡器算法
- 取模法: 无法适应后端服务器个数的改变
- 一致性hash算法: 使用环形hash来计算，但可能会出现偏斜
  - 虚拟服务器: 后端服务器在环上虚拟多个点，使命中平衡
- ebtree: 弹性二叉树
*** 配置
- 配置文件: /etc/haproxy/haproxy.cfg
**** 全局配置
#+BEGIN_SRC conf
global  # 全局配置
    log 127.0.0.1 local2  # 配置日志服务器，可配置两个
    log-send-hostname [string] # 在日志中记录该服务器的主机名

    chroot /var/lib/haproxy  # 运行的目录，提高安全性
    pidfile /var/run/haproxy.pid
    user haproxy
    group haproxy

    daemon  # 若不加则运行在前端
    nbproc 1  # 启动的进程数，默认为1个，多个一般用于调试
    maxconn 4000  # 每个进程的最大连接数

    spread-checks [0-50] # 分散健康状态检查的发送时间
#+END_SRC
**** 代理配置
#+BEGIN_SRC conf
defaults  # 用于为所有其它配置段提供默认参数

frontend main  # 定义监听的套接字
    bind *:80
    use_backend
    default_backend websrvs

defaults  # 重新设定默认参数

backend websrvs  # 定义后端服务器
    balance roundrobin
    server web1 172.16.100.68 check
    server web2 172.16.100.69 check

listen  # 同时定义前端与后端
    ...
#+END_SRC
**** 代理参数
1. balance: 指名调度算法
   - roundrobin: 动态加权轮询，每个后端主机最多接受4128个连接
   - static-rr: 静态加权轮询，每个后端主机支持的数量无上限
   - leastconn: 分配给最少连接数的后端，适用于长时间的会话(如SQL、SSH等)
   - source: 将请求的源地址进行hash运算，并由后端服务器的权重总数相除后派发至某匹配的服务器
   - uri: 对URI(不包含主机名)的"?"之前的部分进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器
   - uri_param: 对URI中的指定参数(";"后"?"之前的<param>)的值进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器
   - hdr(<name>): 对HTTP首部中的参数name的值进行hash运算，并由服务器的总权重相除后派发至某匹配的服务器
2. hash-type: 指定算法中的hash算法类型
   - map-based：取模法(静态)，默认配置
   - consistent：一致性hash算法(动态)
3. bind: 指名监听的端口，只能用于frontend, listen
4. mode {tcp|http}: HAProxy的工作模式，默认为tcp
5. log: 为每个实例指定log
   #+BEGIN_SRC conf
   log global
   log <address> <facility> [<level> [<minlevel>]]
   #+END_SRC
6. maxconn: 设定指定前端的最大连接数，默认为2000
7. default_backend: 在没有匹配的"use_backend"规则时为实例指定使用的默认后端
8. use_backend: 条件式匹配后端
   #+BEGIN_SRC conf
   use_backend backend if ACL...
   #+END_SRC
9. server: 为backend声明一个server
   #+BEGIN_SRC conf
   server <name> <addr>[:port] [OPTIONS]
     name: 用于日志和警告

     OPTIONS: 
       backup: 当其他所有服务器不可用时才启动该服务器
       check: 健康状态检测
         inter NUM: 检测时间间隔(单位为ms)，默认为2000
         fall NUM: server从正常状态转换至离线状态需要成功检查的次数
         rise NUM: server从离线状态转换至正常状态需要成功检查的次数
         port NUM: 检测的端口
       cookie <value>: 为server设定cookie，用于实现持久连接的功能，需要启用cookie功能
       maxconn NUM: 此服务接受的并发连接的最大数量
       maxqueue NUM: 请求队列的最大长度
       observe {layer4|layer7}: 根据流量判断后端server的健康状态
       weight: 指定权重，默认为1，最大为256，0表示不被调度
       redir <prefix>: 重定向，所有发往此服务器的请求均以302响应
   #+END_SRC
10. option *chk: 设定后端的健康状态检测方式
    #+BEGIN_SRC conf
    option httpchk [<method> <uri> <head>]
    option tcp-chk
    #+END_SRC
11. cookie: 启用基于cookie的后端服务器绑定，可以实现浏览器绑定
    #+BEGIN_SRC conf
    cookie <name> insert indirect [OPTIONS]
    #+END_SRC
12. stats: 启用状态监控页
    #+BEGIN_SRC conf
    listen statistics 
      bind *:9090
      stats enable
      stats hide-version  # 隐藏版本号 
      #stats scope .  # 设定作用的backend
      stats uri /haproxyadmin?stats  # 访问路径
      stats realm "HAPorxy\ Statistics"  # 服务器提示
      stats auth admin:mageedu  # 定义账号和密码
      stats admin if TRUE  # 启用管理员功能，可以对后端服务器进行操作
    #+END_SRC
13. errorfile: 定义错误状态码返回的页面文件，但404需要后端服务器返回
    #+BEGIN_SRC conf
    errorfile <code> <file>
    #+END_SRC
14. errorloc: 定义错误状态码返回的重定向，但404需要后端服务器返回
    #+BEGIN_SRC conf
    errorloc <code> <url>  # 使用302状态码进行返回
    errorloc303 <code> <url>  # 使用303状态码进行返回
    #+END_SRC
15. capture: 捕获指定参数最近一次出现的第一个值，记录在日志中
    #+BEGIN_SRC conf
    capture request header <name> len <length>  # 捕获请求报文
    capture response header <name> len <length>  # 捕获响应报文
    #+END_SRC
16. option httplog: 记录更详细的日志信息
17. option logasap: 在HTTP请求处理记录日志，默认是HTTP请求结束后才记录日志，但无法记录传输字节数
18. option forwardfor: 允许在发往服务器的请求首部中插入"X-Forwarded-For"首部，记录客户端地址，用于后端的日志记录
    #+BEGIN_SRC conf
    option forwardfor [ except <network> ] [ header <name> ] [ if-none ]
    #+END_SRC
19. http_request: 用于定义访问控制
    #+BEGIN_SRC conf
    http_request allow if ACL...
    http_request deny  # 定义默认规则
    #+END_SRC
20. option http-server-close: 打开与客户端保持连接的断开功能
21. option http-pretend-keepalive: 打开与后端的保持连接功能
22. redirect: 重定向访问地址
    #+BEGIN_SRC sh
    redirect prefix https://www.qiump.com if ACL...  # 重定向主机地址和协议
    redirect location / clear-cookie USERID= if logout  # 重定向页面和清除cookie
    #+END_SRC
23. reqadd/rspadd: 添加请求或响应报文首部
    #+BEGIN_SRC conf
    reqadd <string> [if ACL...] 
    rspadd <string> [if ACL...] 
    #+END_SRC
24. timeout: 定义各种超时时长
    #+BEGIN_SRC conf
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    #+END_SRC
**** ACL测试条件
#+BEGIN_SRC conf
acl <aclname> <criterion> [-i] [operator] <value> ...
  aclname: 定义ACL的名字，可以重复(表示合并)
  criterion: 检查条件
  -i: 匹配忽略大小写
  operator: eq、ge、gt、le、lt，用于数值的比较
  value: 可使用整数范围(1024:65535)、字符串、正则表达式、网络地址
#+END_SRC
- 测试条件criterion
  1. be_sess_rate(backend) <int>: 测试backend的会话创建速率，一般用于阻止攻击行为
     #+BEGIN_SRC conf
     acl being_scanned be_sess_rate gt 50
     redirect location /error_pages/denied.html if being_scanned
     #+END_SRC
  2. fe_sess_rate <int>: 测试frontend的会话创建速率
     #+BEGIN_SRC conf
     acl too_fast fe_sess_rate ge 50
     tcp-request inspect-delay 500ms
     tcp-request content accept if ! too_fast  # 测试速率
     tcp-request content accept if WAIT_END  # WAIT_END表示延迟时间是否到达
     #+END_SRC
  3. 测试请求的路径
     - path_beg <str>: 测试请求的路径是否以<str>指定的模式开头
     - path_end <str>: 测试请求的路径是否以<str>指定的模式结尾
     - path_reg <str>: 对路径进行正则匹配
  4. 测试请求的URL
     - url_beg <str>
     - url_end <str>
     - url_reg
  5. method <str>: 测试HTTP请求报文中使用的方法
  6. 测试请求报文的首部
     - hdr(header) <str>: 测试请求报文中的所有首部或指定首部是否满足指定的条件
     - hdr_beg(header) <str>
     - hdr_end(header) <str>
- 多个测试条件可以用逻辑操作符进行组合，如"||"、"!"，默认为"与"



